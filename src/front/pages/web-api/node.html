<h1 class="app-no-margin-top">Node</h1>

<div app-playground>
  <div id="root">
    Level 1
    <div>
      Level 1.1
      <div>Level 1.1.1</div>
      <div>Level 1.1.2</div>
    </div>
    <div>
      Level 1.2
      <div>Level 1.2.1</div>
    </div>
    <div>
      Level 1.3
      <div>Level 1.3.1</div>
      <div>Level 1.3.2</div>
      <div>Level 1.3.3</div>
    </div>
  </div>

  <div id="actions">
    <button data-direction="up">&uparrow;</button>
    <br>
    <button data-direction="left">&leftarrow;</button>
    <button data-direction="right">&rightarrow;</button>
    <br>
    <button data-direction="down">&downarrow;</button>
  </div>
</div>

<style app-playground>
  #root, #root * {
    margin: 0.3rem 0.6rem;
    padding: 0.3rem 0.6rem;
    border-width: 1px;
    border-style: dashed;
  }

  #root { border-color: green; }
  #root > * { border-color: blue; }
  #root > * > * { border-color: red; }

  #actions { text-align: center; }

  .highlight { background-color: yellow; }
</style>

<script app-playground>
  var root = document.getElementById('root');
  var node = root;
  node.classList.add('highlight');

  function moveTo(target) {
    node.classList.remove('highlight');
    target.classList.add('highlight');
    node = target;
  }

  function noMoveTo(direction) {
    Playground.log(`Can't go ${direction}!`);
  }

  document.getElementById('actions').addEventListener('click', function(event) {
    if (event.target.nodeName === 'BUTTON') {
      const direction = event.target.dataset.direction;
      if (node === root && direction !== 'down') {
        noMoveTo(direction);
        return;
      }
      switch (direction) {
        case 'up': {
          moveTo(node.parentNode);
          break;
        }
        case 'left': {
          let target = node;
          while ((target = target.previousSibling) && (target.nodeType !== Node.ELEMENT_NODE)) {}
          target ? moveTo(target) : noMoveTo(direction);
          break;
        }
        case 'right': {
          let target = node;
          while ((target = target.nextSibling) && (target.nodeType !== Node.ELEMENT_NODE)) {}
          target ? moveTo(target) : noMoveTo(direction);
          break;
        }
        case 'down': {
          let target = node.firstChild;
          while (target && (target.nodeType !== Node.ELEMENT_NODE)) {
            target = target.nextSibling;
          }
          target ? moveTo(target) : noMoveTo(direction);
          break;
        }
      }
    }
  });
</script>

<pre>parentNode (parentElement)
previousSibling
nextSibling
childNodes
firstChild
lastChild

isConnected
hasChildNodes
contains

appendChild
inserBefore
removeChild
replaceChild
cloneNode

textContent
getRootNode
normalize</pre>
